# 1章 並行処理入門

## 並行処理で起きる問題
### 競合状態
2つ以上の操作が正しい順番で行われなければならないところで順序が保障されていなかったときに発生する問題．

#### データ競合
- Read, Writeの実行順序が保障されていなかった時に起きる問題
- 同一のコードを実行しても，結果が定まらない

```
package main

import "fmt"

func main() {
	var data int

	go func() {
		data++ // Write
	}()

	if data == 0 { // Read 1
		fmt.Println("The val is %v") // Read 2
	}
}

```

- 上記のサンプルであれば3通りの結果が考えられる
    - WriteがRead1, Read2の処理のどこで実行されるかによる
    - 例
        - なにも表示されない
        - 1と表示
        - 0と表示
	- 各処理が実行されるまでに長時間（1hなど）空いたらどうなるか考えてみる
- 論理的正当性を目指すべき

### アトミック性（原子性）
- 何かがアトミックである <-> それが操作されている特定のコンテキストの中では分割，中断不可であること
- ほとんどの式（expression）はatomicではない
- あるものがアトミックであるかはコンテキストで異なる
	- アプリケーションのコンテキストではアトミックでも，OSのコンテキストではアトミックではないかもしれない
- 分割不可，中断不可 <-> アトミックな処理が起きた場合，そのコンテキスト全体で処理をしていてその他の何かが同時には起きていないこと
- あるものがアトミックである <-> 複数の並行なコンテキストで安全に扱えることが暗黙に保障される

### メモリアクセス競合
- クリティカルセクション <->　排他的な処理が必要な場所
	- 共有リソースにアクセスする場所
		- 変数へのRead, Writeが起きる場所
- クリティカルセクションに排他的な処理を追加することでアトミックな処理にできる？


```
package main

import (
	"fmt"
	"sync"
)

func main() {
	var memoryAccess sync.Mutex
	var value int

	go func() {
		memoryAccess.Lock()
		value++
		memoryAccess.Unlock()
	}()

	memoryAccess.Lock()
	if value == 0 {
		fmt.Printf("The value is %v\n", value)
	} else {
		fmt.Printf("The value is %v\n", value)
	}
	memoryAccess.Unlock()

}
```

- 排他的な処理の導入で何か解決している？
	- 非決定的な挙動をする範囲を小さくしている
	- Read1, Read2の間にはWriteが実行されない

### デッドロック，ライブロック，リソース枯渇

#### デッドロック
- 全ての並行なプロセスがお互いの処理を待っている状態
- 外部の介入がない限り処理が動作しない

- デッドロックが起きるときの条件（Coffman条件）
	- 相互排他
		- リソースに対して排他的な権利をどの時点においても所持している
	- 条件待ち
		- ある並行プロセスはリソースの保持，追加のリソース待ちを同時に行わなければならない
	- 横取り不可
		- ある並行プロセスによって保持されているリソースはそのプロセスによってのみ開放される
	- 循環待ち
		- ある並行プロセスP1は他の連なっているP2を待たなければならない．また，P2はP1を待っている

#### ライブロック
- 並行操作が行われているものの，処理が進んでいない状態
- 互いにロックを譲り合ってしまうケースなど

#### リソース枯渇
- 並行プロセスが処理を行うのに必要なリソースを取得できない状態
	- 共有ロック（ソフトウェア上のリソース）
	- メモリ，CPUなど（ハードウェア上のリソース）
- 例
	- タスク1ループ全体でロックを取得，開放するGo routine
	- タスク1ループで細かくロックを取得，開放するGo routine
	- 前者の方が多くタスクを行えている
		- 他のプロセスのタスクに必要なリソースを占有しているため
```
$ go run chapters/1/lack-of-resource.go 
Greedy Worker work count 993325 
Polite Worker work count 376321 
```

