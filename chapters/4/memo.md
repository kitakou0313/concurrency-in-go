# Goでの並行処理パターン

## 拘束
- 並行なコードで安全な操作をするための方法の一つ
- 情報を一つの並行プロセスからのみ得られることを確実にする方法
    - 暗黙的に安全で同期が必要なくなる
- 種類
    - アドホック
        - コーディング規約，静的解析などで実現
    - レキシカル
        - コンパイラの機能を用いて拘束を強制する
- レキシカル拘束
    - レキシカルスコープを使い，データと並行処理のプリミティブだけを複数の並行プロセスが使えるように公開する
    - 方法
        - 読み込み専用，書き込み専用のチャンネルを用いる
        - データの一部分のみを引数として渡し，単一のGo routineのスレッドからのみアクセスできないようにする

## Go routine leak
- Go routineが終了せず割り当てられたメモリが回収されない事によりメモリリークが発生する
- リークを防ぐ方法
    - Go routine生成の責任を持つGo routineは生成したGo routineを停止できるようにする規約を導入する

## OR チャンネルパターン
- 1つ以上の`done`チャンネルの内．どれか一つがCloseされたときに処理を停止するためのパターン

## エラーハンドリング
- 並行プロセス内で起きたエラーは，プログラムの構造を完全に把握しており他の情報と合わせて処理可能な処理に渡すべき
- Goでのエラーの考え方
    - エラーはその処理から返される値を構築するための第一級市民として扱われるべき
    - 正常系と同じ経路を使って渡されるべき
    - https://go.dev/blog/errors-are-values


## パイプラインパターン
- 要素に対して行う処理をステージと呼ばれる処理に抽出するパターン
- 持つ性質
    - 入力と出力が同じ型である
    - 各ステージは引きまわせるように具体化されていなければならない
        - 変数などに代入でき，関数に引数として渡せる
        - 具体例
            - Goの関数
            - Goのチャンネル
    - 望ましい性質
        - スレッドセーフ（並行処理で安全に扱える　　　　　　　　　　　　　　　　　　　）
- メリット
    - 各ステージの懸念事項や値などを切り出せる
- デメリット
    - メモリ使用量がステージの段数 * 入力サイズになる
        - 入力された値のコピーを返す実装の場合
- 近い概念としてストリームがある
    - 要素をひとつづつ受け取る

### ベストプラクティス
- Channelを使ったパターン
    - 多段にしてGo routine内で処理させることで，各ステージごとに並列実行できる
        - CPUのパイプラインと同じ

### 便利なジェネレータ
